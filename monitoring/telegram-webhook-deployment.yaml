# Telegram Webhook Server Deployment
# Simple HTTP server that receives alerts from Alertmanager and forwards to Telegram
# –î–∞—Ç–∞: 2026-01-08

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: telegram-webhook
  namespace: monitoring
  labels:
    app: telegram-webhook
spec:
  replicas: 1
  selector:
    matchLabels:
      app: telegram-webhook
  template:
    metadata:
      labels:
        app: telegram-webhook
    spec:
      initContainers:
      - name: install-requests
        image: python:3.11-slim
        command: ["sh", "-c", "pip install --no-cache-dir requests && cp -r /usr/local/lib/python3.11/site-packages/* /shared/ 2>/dev/null || true"]
        volumeMounts:
        - name: shared-packages
          mountPath: /shared
      containers:
      - name: webhook
        image: python:3.11-slim
        command: ["sh", "-c", "export PYTHONPATH=/shared:/usr/local/lib/python3.11/site-packages && python3 /app/webhook_server.py"]
        ports:
        - name: http
          containerPort: 8080
        env:
        - name: TELEGRAM_BOT_TOKEN
          valueFrom:
            secretKeyRef:
              name: alertmanager-telegram
              key: TELEGRAM_BOT_TOKEN
        - name: TELEGRAM_CHAT_ID
          valueFrom:
            secretKeyRef:
              name: alertmanager-telegram
              key: TELEGRAM_CHAT_ID
        - name: WEBHOOK_PORT
          value: "8080"
        volumeMounts:
        - name: webhook-script
          mountPath: /app
        - name: shared-packages
          mountPath: /shared
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 128Mi
      volumes:
      - name: webhook-script
        configMap:
          name: telegram-webhook-script
      - name: shared-packages
        emptyDir: {}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: telegram-webhook-script
  namespace: monitoring
data:
  webhook_server.py: |
    #!/usr/bin/env python3
    """Simple Telegram Webhook Server for Alertmanager"""
    import os
    import json
    import logging
    from http.server import HTTPServer, BaseHTTPRequestHandler
    import requests

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
    TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")

    def send_telegram_message(text: str) -> bool:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        data = {"chat_id": TELEGRAM_CHAT_ID, "text": text, "parse_mode": "HTML"}
        try:
            response = requests.post(url, json=data, timeout=10)
            response.raise_for_status()
            return True
        except Exception as e:
            logger.error(f"Failed to send Telegram message: {e}")
            return False

    def format_alert(alert_data: dict) -> str:
        alerts = alert_data.get("alerts", [])
        if not alerts:
            return "Empty alert"
        alert = alerts[0]
        labels = alert.get("labels", {})
        annotations = alert.get("annotations", {})
        status = alert.get("status", "unknown")
        alertname = labels.get("alertname", "Unknown")
        severity = labels.get("severity", "unknown")
        summary = annotations.get("summary", "No summary")
        description = annotations.get("description", "No description")
        if status == "resolved":
            emoji = "‚úÖ"
            status_text = "RESOLVED"
        else:
            emoji = "üö®üö®üö®" if severity == "critical" else "‚ö†Ô∏è"
            status_text = "CRITICAL" if severity == "critical" else "WARNING"
        return f"""{emoji} <b>{status_text} ALERT</b>

<b>Alert:</b> {alertname}
<b>Severity:</b> {severity}
<b>Status:</b> {status_text}

<b>Summary:</b>
{summary}

<b>Description:</b>
{description}"""

    class AlertWebhookHandler(BaseHTTPRequestHandler):
        def do_POST(self):
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length)
            try:
                alert_data = json.loads(post_data.decode('utf-8'))
                logger.info(f"Received alert: {alert_data.get('alerts', [{}])[0].get('labels', {}).get('alertname', 'Unknown')}")
                message = format_alert(alert_data)
                success = send_telegram_message(message)
                self.send_response(200 if success else 500)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"status": "ok" if success else "error"}).encode())
            except Exception as e:
                logger.error(f"Error processing alert: {e}")
                self.send_response(400)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"status": "error", "message": str(e)}).encode())
        def do_GET(self):
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(b"OK")
        def log_message(self, format, *args):
            logger.info(f"{self.address_string()} - {format % args}")

    if __name__ == "__main__":
        port = int(os.getenv("WEBHOOK_PORT", "8080"))
        server = HTTPServer(('0.0.0.0', port), AlertWebhookHandler)
        logger.info(f"Telegram webhook server started on port {port}")
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            logger.info("Shutting down server...")
            server.shutdown()
---
apiVersion: v1
kind: Service
metadata:
  name: telegram-webhook
  namespace: monitoring
  labels:
    app: telegram-webhook
spec:
  type: ClusterIP
  ports:
  - port: 8080
    targetPort: 8080
    name: http
  selector:
    app: telegram-webhook

